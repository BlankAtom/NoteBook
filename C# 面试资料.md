# C# 面试资料

# 1. 值类型和引用类型

## 值类型

简单类型，结构体，枚举类型；

特点：在**线程栈**中分配内存，会自动释放，比较高效；但是**不允许派生**，**不支持多态**；适合做数据的载体。

值类型变量做为局部变量时，该实例将被创建在堆栈上；而如果值类型变量作为类型的成员变量时，它将作为类型实例数据的一部分，同该类型的其他字段都保存在托管堆上。



## 引用类型

自定义类，接口，string类型，数组，委托；

特点：在**托管堆**中分配内存，需要手动释放；**可以派生**，**支持多态**；适合定义应用的行为。

引用类型变量数据保存在托管堆上，但是根据实例的大小有所区别：当实例的大小**<85000Byte**时实例将创建在**GC堆**上；当实例大小**>=85000byte**时，则该实例创建在**LOH（Large Object Heap）堆上**。





# 2. 装箱、拆箱

## 装箱

将值类型打包到引用类型叫做装箱；



装箱时到底发生的事情：

1）、在托管堆中分配内存。分配的内存量是值类型各字段所需的内存量，还要加上托管堆所有对象都有的两个额外成员（**类型对象指针和同步块索引**）所需的内存量

2）、值类型的字段复制到新分配的堆内存

3）、返回对象地址，现在该地址是对象引用；值类型成了引用类型



## 拆箱

将引用类型转为值类型叫做拆箱；

拆箱不是装箱过程倒过来，拆箱的代价要**比装箱低**的多，**拆箱是获取指针的过程**，该指针指向包含在一个对象中的原始值类型。**拆箱后将堆中的字段包含的值复制到栈的值类型实例中。**



# 3. 继承、多态、封装

> 此处使用Java的内容，彼此互通



​        面向对象编程是利用类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物，面向对象的三大特征封装，继承，多态。封装，封装说明一个类行为和属性与其他类的关系，低耦合，高内聚；继承是父类和子类的关系，多态说的是类与类的关系。

​		封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。属性的封装：使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的 不合理操作；方法的封装：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用； 便于修改，增强 代码的可维护性；

​		继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本质上是特殊~一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性 ，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。继承的类叫做子类（派生类或者超类），被继承的类叫做父类（或者基类）。比如从猫类、狗类、虎类中可以抽象出一个动物类，具有和猫、狗、虎类的共同特性（吃、跑、叫等）。Java通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围，在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。

​		相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态， 多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。多态必备三个要素：继承，重写，父类引用指向子类对象。



# 4. 泛型

## 泛型类

```C#
class BaseNode<T, int> where T : System.IComparable<T>, new(){ }
```



## 泛型接口

泛型类的首选使用是泛型接口。

```C#
interface IDictionary<K, V> {}
```



## 泛型方法

```C#
void DoWork() {}
void DoWork<T>(){ }
void DoWork<T, U>() {}
```

> 泛型方法可以重载



## 类型参数的约束

```C#
where T : struct; // 不可为null的值类型
where T : class ; // 必须是引用类型
where T : class?; // 可为null的引用类型
where T : new() ; // 具有公共无参数构造函数，和其他约束一起使用时，必须最后指定
where T : BaseClassName; // 基类约束
```

#### 约束多个参数

```c#
class Base { }
class Test<T, U>
    where U : struct
    where T : Base, new()
{ }
```



#### 未绑定的类型参数

没有约束的类型参数（如公共类 `SampleClass<T>{}` 中的 T）称为未绑定的类型参数。 未绑定的类型参数具有以下规则：

- 不能使用 `!=` 和 `==` 运算符，因为无法保证具体的类型参数能支持这些运算符。
- 可以在它们与 `System.Object` 之间来回转换，或将它们显式转换为任何接口类型。
- 可以将它们与 [null](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/null) 进行比较。 将未绑定的参数与 `null` 进行比较时，如果类型参数为值类型，则该比较将始终返回 false。



# 5. `Array`、`ArrayList`、`List<T>`

在C#中数组Array，ArrayList，泛型List都能够存储一组对象

## `Array`

数组是一个存储相同类型元素的固定大小的顺序集合。

Array 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。

数组在内存中是**连续存储**的，所以它的索引速度非常快，而且赋值与修改元素也非常简单。



### 缺点：

1、在声明数组的时候必须指定数组的长度，如果不清楚数组的长度，就会变得很麻烦。

2、数组的长度太长，会造成内存浪费；太短会造成数据溢出的错误。

3、在数组的两个数据间插入数据是很麻烦的









## `ArrayList`

既然数组有很多缺点，C#就提供了ArrayList对象来克服这些缺点。

ArrayList是在命名空间`System.Collections`下，在使用该类时必须进行引用，同时继承了`IList`接口，提供了数据存储和检索。

`ArrayList`对象的大小是按照其中存储的数据来动态扩充与收缩的。因此在声明`ArrayList`对象时并不需要指定它的长度。

`ArrayList` 的默认初始容量为 0。随着元素添加到 `ArrayList` 中，容量会根据需要通过重新分配自动增加。可通过调用` TrimToSize` 或通过显式设置 `Capacity` 属性减少容量。

ArrayList解决了数组中所有的缺点，但是在存储或检索值类型时通常发生**装箱和取消装箱**操作，带来很大的性能耗损。尤其是装箱操作，例如：

```C#
ArrayList list = new ArrayList();

//add 
list.Add("joye.net");
list.Add(27);

//update  
list[2] = 28;

//delete 
list.RemoveAt(0);

//Insert  
list.Insert(0, "joye.net1");
```

在List中，先插入了字符串`joye.net`，而且插入了int类型27。这样在ArrayList中插入不同类型的数据是允许的。因为ArrayList会把所有插入其中的数据当作为object类型来处理，在使用ArrayList处理数据时，很可能会报类型不匹配的错误，也就是**ArrayList不是类型安全的**。



## `List<T>`

由于`ArrayList`存在不安全类型与装箱拆箱的缺点，所以出现了泛型的概念。

`List` 类是 `ArrayList` 类的泛型等效类。该类使用大小可按需动态增加的数组实现 `IList` 泛型接口，大部分用法都与`ArrayList`相似。

`List<T>` 是类型安全的，在声明List集合时，必须为其声明List集合内数据的对象类型。

如果声明List集合内数据的对象类型是string，然后往List集合中插入int类型的111，IDE就会报错，且不能通过编译。



# 6. `HashTable`、`Dictionary`、`ConcurrentDictionary`三者区别

## `HashTable`

`HashTable`表示键/值对的集合。在`.NET Framework`中，`Hashtable`是`System.Collections`命名空间提供的一个容器，用于处理和表现类似`key-value`的键值对，其中`key`通常可用来快速查找，同时key是区分大小写；value用于存储对应于key的值。`Hashtable`中`key-value`键值对均为`object`类型，所以`Hashtable`可以支持任何类型的`key-value`键值对，任何非 null 对象都可以用作键或值。

`HashTable`是一种散列表，他内部维护很多对`Key-Value`键值对，其还有一个类似索引的值叫做散列值(`HashCode`)，它是根据`GetHashCode`方法对Key通过一定算法获取得到的，所有的查找操作定位操作都是基于散列值来实现找到对应的Key和Value值的。

散列函数(`GetHashCode`)让散列值对应`HashTable`的空间地址尽量不重复。

当一个`HashTable`被占用一大半的时候我们通过计算散列值取得的地址值可能会重复指向同一地址，这就造成哈希冲突。

> C#中键值对在`HashTable`中的位置`Position= (HashCode& 0x7FFFFFFF) % HashTable.Length`，C#是通过探测法解决哈希冲突的，当通过散列值取得的位置`Postion`以及被占用的时候，就会增加一个位移x值判断下一个位置`Postion + x`是否被占用，如果仍然被占用就继续往下位移x判断`Position + 2 * x`位置是否被占用，如果没有被占用则将值放入其中。当`HashTable`中的可用空间越来越小时，则获取得到可用空间的难度越来越大，消耗的时间就越多。





## `Dictionary`

`Dictionary<TKey, TValue>` 泛型类提供了从一组键到一组值的映射。通过键来检索值的速度是非常快的，接近于 O(1)，这是因为 `Dictionary<TKey, TValue>` 类是作为一个哈希表来实现的。检索速度取决于为 `TKey` 指定的类型的哈希算法的质量。`TValue`可以是值类型，数组，类或其他。

`Dictionary`是一种变种的`HashTable`,它采用一种**分离链接散列表**的数据结构来解决哈希冲突的问题。



## `ConcurrentDictionary`

表示可由多个线程同时访问的键/值对的**线程安全集合**。

`ConcurrentDictionary<TKey, TValue>` framework 4出现的，可由多个线程同时访问，且线程安全。用法同Dictionary很多相同，但是多了一些方法。`ConcurrentDictionary` 属于`System.Collections.Concurrent` 命名空间按照MSDN上所说：

> `System.Collections.Concurrent` 命名空间提供多个线程安全集合类。当有多个线程并发访问集合时，应使用这些类代替 `System.Collections` 和 `System.Collections.Generic` 命名空间中的对应类型。



## 总结

大数据插入`Dictionary`花费时间最少

遍历`HashTable`最快，是Dictionary的1/5，`ConcurrentDictionary`的1/10

单线程建议用Dictionary，多线程建议用`ConcurrentDictionary`或者`HashTable`（`Hashtable tab = Hashtable.Synchronized(new Hashtable());`获得**线程安全的对象**）



# 7. 特殊字符

## 字符串内插——$

`$` 特殊字符将字符串文本标识为内插字符串。 内插字符串是可能包含内插表达式的字符串文本 。 将内插字符串解析为结果字符串时，带有内插表达式的项会替换为表达式结果的字符串表示形式。 从 C# 6 开始可以使用此功能。

字符串内插为格式化字符串提供了一种可读性和便捷性更高的方式。 它比[字符串复合格式设置](https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/composite-formatting)更容易阅读。 比较一下下面的示例，它使用了这两种功能产生相同的输出：

```c#
string name = "Mark";
var date = DateTime.Now;

// Composite formatting:
Console.WriteLine("Hello, {0}! Today is {1}, it's {2:HH:mm} now.", name, date.DayOfWeek, date);
// String interpolation:
Console.WriteLine($"Hello, {name}! Today is {date.DayOfWeek}, it's {date:HH:mm} now.");
// Both calls produce the same output that is similar to:
// Hello, Mark! Today is Wednesday, it's 19:40 now.
```



## 逐字字符串标识符——@

1、使用C#关键字作为标识符时，可以使用@字符作为代码元素的前缀

2、字符串中不作转义字符时，使用@符号作为字符串的前缀

```c#
string filename1 = @"c:\documents\files\u0066.txt";
```







# 8. 委托

[委托](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types)是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。 在实例化委托时，你可以将其实例与任何具有兼容签名和返回类型的方法相关联。 你可以通过委托实例调用方法。

委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。

[委托](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types)是安全封装方法的类型，类似于 C 和 C++ 中的函数指针。 与 C 函数指针不同的是，委托是面向对象的、类型安全的和可靠的。

事件和委托没有区别，事件是特殊的委托。



## `delegate`

```C#
public delegate int PerformCalculation(int x, int y);
```



## `Action`

委托代理的简化方式.

不能有返回值

```C#
public Action<string> Print;
```





## `Func`

返回值是末尾参数

```c#
public Func<string, string, int> _func;
```



# 9. 抽象类和接口

![image-20220322165834842](https://hong-not-pic-1258424340.cos.ap-nanjing.myqcloud.com/notepic/202203221802988.png)





# 10. 进程、线程

## 线程

##### 概念：

线程是进程中执行运算的**最小单位**，是**进程中的一个实体**，是被**系统独立调度**和**分派**的**基本单位**，线程自己**不拥有系统资源**，只拥有**一点在运行中必不可少的资源**，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。 

##### 好处：

（1）易于调度。 

（2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。 

（3）开销少。创建线程比创建进程要快，所需开销很少。。 

（4）利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。



## 进程

是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。



### 进程的基本状态及状态之间的关系

##### 状态：运行、阻塞、挂起阻塞、就绪、挂起就绪

状态之间的转换：准备就绪的进程，被CPU调度执行，变成运行态； 

运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态； 

运行中的进程，进程执行完毕（或时间片已到），变成就绪态； 

将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态； 

将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态；



### 线程和进程的关系以及区别？

##### 进程和线程的关系：

（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 

（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。 

（3）处理机分给线程，即真正在处理机上运行的是线程。 

（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.



##### 进程与线程的区别：

（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 

（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 

（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 

（4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。





### 进程间通信的方式

（1）管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 

（2）信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。 

（3）[消息队列](https://cloud.tencent.com/product/cmq?from=10680)（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。 

（4）共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 

（5）信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。 

（6）套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。



### 同步和互斥的区别：

当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。 

所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 

 所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 



# 11. 内存管理

## Windows系统中的虚拟寻址系统

该系统把程序可用的内存地址映射到硬件内存中的实际地址上，在32位处理器上的每个进程都可以使用4GB的硬件内存(64位处理器更大)，这个4GB的内存包含了程序的所有部分（包括可执行代码、代码加载的所有DLL、程序运行时使用的所有变量的内容）
这个4GB的内存称为虚拟地址空间，或**虚拟内存**。其中的每个存储单元都是从0开始排序的。要访问存储在内存的某个空间中的一个值，就需要提供表示该存储单元的数字。编译器负责把变量名转换为处理器可以理解的内存地址。

在C#中的数据类型分为值类型和引用类型，对他们使用了不同但又相似的内存管理机制。



#### 值数据类型的内存管理

在进程的虚拟内存中，有一个区域称为栈。C#的值类型数据、传递给方法的参数副本都存储在这个栈中。在栈中存储数据时，是从高内存地址向低内存地址填充的。
操作系统维护一个变量，称为栈指针。栈指针为当前变量所占内存的最后一个字节地址，栈指针会根据需要随时调整，它总是会调整为指向栈中下一个空闲存储单元的地址。当有新的内存需求时，就根据当前栈指针的值开始往下来为该需求分配足够的内存单元，分配完后，栈指针更新为当前变量所占内存的最后一个字节地址，它将在下一次分配内存时调整为指向下一个空闲单元。
如：`int a = 10;`
声明一个整型的变量需要32位，也就是4个字节内存，假设当前栈指针为89999，则系统就会为变量a分配4个内存单元，分别为89996~89999，之后，栈指针更新为89995
`double d = 20.13;` //需要64位，也就是8个字节内存，存储在89988~89995

栈的工作方式是先进后出(FIFO)：在释放变量时，总是先释放后面声明的变量(后面分配内存)。



#### 引用数据类型的内存管理

引用类型对象的引用存储在栈中(占4个字节的空间)，而它的实际数据存储在主托管堆或大对象堆上，托管堆是可用的4GB虚拟内存中的另一个内存区域。
**大对象堆：**在.NET下，因为压缩较大对象(大于85000个字节)很影响性能，所以为它们分配了自己的托管堆。.NET垃圾回收器不对大对象堆执行压缩过程。
如：`Person arabel= new Person();`
声明变量arabel时，在栈上为该变量分配4个字节的空间以存储一个引用，new运算符为对象Person对象在堆上分配空间，然后把该空间的地址赋给变量arabel，而构造函数则用来初始化。

.NET运行库为了给对象arabel分配空间，需要搜索堆，选取第一个未使用的且足够容纳对象所有数据的连续块。但垃圾回收器程序在回收堆中所有无引用的对象后，会执行压缩操作，即：把剩下的有用对象移动到堆的端部，挨在一起形成一个连续的内存块，并更新所有对象的引用为新地址，同时更新堆指针，方便为下一个新对象分配堆空间。

一般情况下，垃圾回收器在.NET运行库认为需要它时运行。
`System.GC`类是一个表示垃圾回收器的.NET类，可以调用`System.GC.Collect()`方法，强迫垃圾回收器在代码的某个地方运行。
当代码中有大量的对象刚刚取消引用，就比较适合调用垃圾回收器，但不能保证所有未引用的对象都能从堆中删除。
垃圾回收器运行时，它实际上会**降低程序的性能**，因为在它执行期间，将会暂停应用程序的其它所有线程。



##### .NET垃圾回收器使用了"世代垃圾回收器(generational)"：

托管堆分为几个部分：第0代，第1代，第2代
所有新对象都被分配在第0代部分，在给新对象分配堆空间时，如果超出了第0代对应的部分的容量，或者调用了`GC.Collect()`方法，就会开始进行垃圾回收。
每当垃圾回收器执行压缩时，第0代部分留下来的对象将会被移动到第1代上，此时第0代部分就变成空，用来放置下一个新对象。
类似的，当第一代满时，也会进行压缩，剩下对象移到下一代。
托管堆有一个堆指针，功能和栈指针类似。





# 12. 垃圾回收

**根（Roots）**

类中定义的任何的静态字段、方法的参数、局部变量（仅限引用类型变量）等都是根，根是CLR在堆之外可以找到的各种入口点。垃圾回收器会去检查所有的**应用程序根**，遍历每个根所引用到的对象，将其标记为活动的（live ），所有的根对象都检查完之后，有标记的对象就是**可达对象**，未标记的对象就是**不可达对象**，不可达对象就是回收的目标。



## 回收过程

CLR开始GC时，首先会暂停进程中所有的线程，这样可以防止线程在CLR检查期间访问对象并更改其状态。

(1) 标记

标记的过程，其实就是判断对象是否可达的过程，即将该对象的**同步块索引**中的位设置为1，一个对象被标记后，CLR会检查那个对象的根，标记它们引用的对象，如果发现对象已经被标记，就不重新检查对象的字段，避免因为循环引用而产生的死循环。当所有的根都检查完毕后，堆中将包含可达（已标记）与不可达（未标记）对象；

(2)清除

标记完成后将不可达对象清除。

(3)压缩

垃圾回收器线性遍历堆，寻找到不可达对象的连续内存块，把可达对象移动到这里以压缩堆。这个过程有点类似磁盘空间的碎片整理。



压缩之后，指向这些对象的指针都会失效，垃圾回收器必须重新访问所有根，并修改它们来指向对象的新内存位置。托管堆的NextObjPtr指针指向了最后一个幸存对象之后的位置，下一个分配对象将放在这个位置。该阶段完成后，CLR恢复应用程序的所有线程，这些线程会继续访问对象，就好像GC从未发生过一样。



## GC算法 - 分代算法（Generation）

对象越新，生存期越短；

对象越老，生存期越长；

回收堆的一部分，速度快于回收整个堆；



# 13. C# 的特性

## 1) async / await

使用它们标记函数，可以轻松快捷的创建异步编程模型。

**async**

放在函数前面，定义异步方法。



**await**

在async方法里使用的关键字，会等待标识的目标执行完成；





```C#
public async Task<int> GetUrlContentLengthAsync()
{
    var client = new HttpClient();

    Task<string> getStringTask =
        client.GetStringAsync("https://docs.microsoft.com/dotnet");

    DoIndependentWork();

    string contents = await getStringTask;

    return contents.Length;
}

void DoIndependentWork()
{
    Console.WriteLine("Working...");
}
```



如果使用 [async](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/async) 修饰符将某种方法指定为异步方法，即启用以下两种功能。

- 标记的异步方法可以使用 [await](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/await) 来指定暂停点。 `await` 运算符通知编译器异步方法：在等待的异步过程完成后才能继续通过该点。 同时，控制返回至异步方法的调用方。

  异步方法在 `await` 表达式执行时暂停并不构成方法退出，只会导致 `finally` 代码块不运行。

- 标记的异步方法本身可以通过调用它的方法等待。





## 2) 初始值设定项

```c#
public class Employee {

    public string Name {get; set;}

    public DateTime StartDate {get; set;}

}

// 使用初始值设定项创建员工实例

Employee emp = new Employee {Name="John Smith", StartDate=DateTime.Now()};
```





## 3）Lambda表达式、闭包



## 4）`??` - null合法运算符

当表达式左侧不为null时，返回左侧的值，否则返回右侧；



## 5）内插字符串





## 6）`?.` - null条件运算符



## 7） `nameof` 表达式



## 8）属性初始值设定项



## 9）as / is 运算符

is运算符用来判断一个实例是否是特定类型的。

as运算符则会试图将某个对象转换成指定特定类的实例，如果无法完成的话会返回null；



## 10）yield关键字

你可以使用yield来返回`IEnumerable`接口的数据项。





# 参考资料

《深入理解C#》第二版

《CLR VIA C#》第四版

《C# 高级编程》第四版

[C# 垃圾回收机制 - 简书 (jianshu.com)](https://www.jianshu.com/p/cc57aa7f3824)