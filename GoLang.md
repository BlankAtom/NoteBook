# GoLang

## 简介

Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是非常年轻的一门语言，它的主要目标是“兼具 [Python](http://c.biancheng.net/python/) 等动态语言的开发速度和 C/[C++](http://c.biancheng.net/cplus/) 等编译型语言的性能与安全性”。

Go语言是编程语言设计的又一次尝试，是对类C语言的重大改进，它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。Go语言的用途众多，可以进行网络编程、系统编程、并发编程、分布式编程。

Go语言的推出，旨在不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势，目前国内诸多 IT 公司均已采用Go语言开发项目。

Go语言有时候被描述为“C 类似语言”，或者是“21 世纪的C语言”。Go 从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。

因为Go语言没有类和继承的概念，所以它和 [Java](http://c.biancheng.net/java/) 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说Go语言是一门混合型的语言。



## 特性

1、语法简单

2、并发模型

3、内存分配

4、垃圾回收

5、静态链接

6、标准库

7、工具链



# 标准化输出

```
Go`语言用于控制文本输出常用的标准库是`fmt
```

`fmt`中主要用于输出的函数有:

- Print: 输出到控制台，不接受任何格式化操作
- Println: 输出到控制台并换行
- Printf: 只可以打印出格式化的字符串，只可以直接输出字符串类型的变量（不可以输出别的类型）
- Sprintf: 格式化并返回一个字符串而不带任何输出
- Fprintf: 来格式化并输出到`io.Writers`而不是`os.Stdout`



## 整数格式化

| 格 式 | 描 述                                           |
| ----- | ----------------------------------------------- |
| %b    | 整型以二进制方式显示                            |
| %o    | 整型以八进制方式显示                            |
| %d    | 整型以十进制方式显示                            |
| %x    | 整型以十六进制方式显示                          |
| %X    | 整型以十六进制、字母大写方式显示                |
| %c    | 相应Unicode码点所表示的字符                     |
| %U    | Unicode 字符, Unicode格式：123，等同于 "U+007B" |

fmt.Printf("%0*d", 9, a)

## 浮点数格式化

| 格 式 | 描 述                                                 |
| ----- | ----------------------------------------------------- |
| %e    | 科学计数法，例如 -1234.456e+78                        |
| %E    | 科学计数法，例如 -1234.456E+78                        |
| %f    | 有小数点而无指数，例如 123.456                        |
| %g    | 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 |
| %G    | 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 |

### 浮点数精度控制

你也可以指定浮点型的输出宽度，同时也可以通过 宽度.精度 的语法来指定输出的精度

```go
a := 54.123456
fmt.Printf("|%f|", a)  // |54.123456|
fmt.Printf("|%5.1f|", a)  // | 54.1|
fmt.Printf("|%-5.1f|", a) // |54.1 |
fmt.Printf("|%05.1f|", a) // |054.1|
```



## 布尔类型格式化

| 格 式 | 描 述         |
| ----- | ------------- |
| %t    | true 或 false |



## 字符串格式化

| 格 式 | 描 述                                  |
| ----- | -------------------------------------- |
| %s    | 字符串或切片的无解译字节               |
| %q    | 双引号围绕的字符串，由Go语法安全地转义 |
| %x    | 十六进制，小写字母，每字节两个字符     |
| %X    | 十六进制，大写字母，每字节两个字符     |

### 字符串宽度控制

宽度设置格式: 占位符中间加一个数字, 数字分正负, +: 右对齐, -: 左对齐

1.最小宽度, 不够部分可以选择补`0`

```go
fmt.Printf("|%s|", "aa") // 不设置宽度
fmt.Printf("|%5s|", "aa") // 5个宽度,  默认+， 右对齐
fmt.Printf("|%-5s|", "aa") // 5个宽度, 左对齐

fmt.Printf("|%05s|", "aa") // |000aa|
```

2.最大宽度, 超出的部分会被截断

```go
fmt.Printf("|%.5s|", "xxxx") // 最大宽度为5
```



## 指针格式化

| 格 式 | 描 述                 |
| ----- | --------------------- |
| %p    | 十六进制表示，前缀 0x |



## 通用的占位符

| 格 式 | 描 述                              |
| ----- | ---------------------------------- |
| %v    | 值的默认格式。                     |
| %+v   | 类似%v，但输出结构体时会添加字段名 |
| %#v   | 相应值的Go语法表示                 |
| %T    | 相应值的类型的Go语法表示           |
| %%    | 百分号,字面上的%,非占位符含义      |

## 格式化错误

类型错误或未知: `%!verb(type=value)`

```go
Printf("%d", "hi") // %!d(string=hi)

复制代码
```

N个参数: `%!(EXTRA type=value)`

```go
Printf("hi", "guys") // hi%!(EXTRA string=guys)
复制代码
```

少量参数: `%!verb(MISSING)`

```go
Printf("hi%d") // hi %!d(MISSING)
复制代码
```

宽度/精度不是整数值: `%!(BADWIDTH) or %!(BADPREC)`

```go
Printf("%d", hi) // %!d(string=hi)
复制代码
```



# 转换操作

## []byte和string的转换及性能比较

string类型和[]byte类型是我们编程时最常使用到的数据结构。本文将探讨两者之间的转换方式，通过分析它们之间的内在联系来拨开迷雾。

## 两种转换方式

- **标准转换**

go中string与[]byte的互换，相信每一位gopher都能立刻想到以下的转换方式，我们将之称为标准转换。

```go
// string to []byte
    s1 := "hello"
    b := []byte(s1)

    // []byte to string
    s2 := string(b)
```

- **强转换**

通过unsafe和reflect包，可以实现另外一种转换方式，我们将之称为强转换（也常常被人称作黑魔法）。

```go
func String2Bytes(s string) []byte {
    sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
    bh := reflect.SliceHeader{
        Data: sh.Data,
        Len:  sh.Len,
        Cap:  sh.Len,
    }
    return *(*[]byte)(unsafe.Pointer(&bh))
}

func Bytes2String(b []byte) string {
    return *(*string)(unsafe.Pointer(&b))
}
```



对于性能分析和原理解析，可参见原文

结论是强转换优于标准转换



# 容器（Container）

## 数组

## 多维数组

## 切片

## Range关键字

## 多维切片

## map映射

## sync.Map

## list

## nil

## make & new



# 其他

## 剪贴板操作

clipboard包

## 读取文件的四种方式



# 参考

[Go 之 格式化输出 《Go语言基础》 - 掘金 (juejin.cn)](https://juejin.cn/post/7042636455239221256)

[Golang中[]byte与string转换全解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/270626496)

[golang 读取文件的四种方式 - 简书 (jianshu.com)](https://www.jianshu.com/p/711c453bff16)
